name: inventory-and-ansible

on:
  workflow_run:
    workflows: ["terraform-apply"] # nombre exacto del workflow de apply
    types: [completed]

permissions:
  contents: read
  id-token: write

concurrency:
  group: inv-ansible-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # ──────────────────────────────────────────────────────────────
  # 0) Resolver entorno a partir del workflow que nos ha llamado
  # ──────────────────────────────────────────────────────────────
  resolve-env:
    name: Resolve environment from trigger
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      env: ${{ steps.set-env.outputs.env }}
    permissions:
      actions: read # Requerido para descargar artefactos de otros workflows
    steps:
      - name: Download env artifact from triggering workflow
        uses: actions/download-artifact@v4
        with:
          name: applied-env
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
      - name: Read env from file
        id: set-env
        run: echo "env=$(cat env.txt)" >> $GITHUB_OUTPUT

  # ──────────────────────────────────────────────────────────────
  # 1) Generar inventario para el entorno detectado, y verificar si las instances están arrancadas.
  # ──────────────────────────────────────────────────────────────
  generate_inventory:
    name: Generate inventory
    needs: resolve-env
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Auth GCP (OIDC)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ vars.GCP_SERVICE_ACCOUNT }}
          project_id: ${{ vars.GCP_INFRA_PROJECT_ID }}
          export_environment_variables: true

      - name: Ensure GCP VMs are running
        run: |
          set -euo pipefail
          echo "Checking for stopped GCP instances in environment: ${{ needs.resolve-env.outputs.env }}"
          
          # List all instances for the environment, filter for TERMINATED ones
          STOPPED_INSTANCES=$(gcloud compute instances list \
            --filter="labels.env=${{ needs.resolve-env.outputs.env }} AND status=TERMINATED" \
            --format="value(name,zone)")

          if [ -z "$STOPPED_INSTANCES" ]; then
            echo "No stopped instances found for environment: ${{ needs.resolve-env.outputs.env }}"
          else
            echo "Found stopped instances. Attempting to start them:"
            echo "$STOPPED_INSTANCES" | while read -r INSTANCE_NAME INSTANCE_ZONE; do
              echo "Starting instance: $INSTANCE_NAME in zone: $INSTANCE_ZONE"
              gcloud compute instances start "$INSTANCE_NAME" --zone="$INSTANCE_ZONE" --quiet
            done
            echo "All identified stopped instances have been commanded to start."
            
            # Optional: Add a wait loop to ensure instances are running before proceeding
            echo "Waiting for instances to reach RUNNING state..."
            MAX_WAIT_TIME=300 # 5 minutes
            WAIT_INTERVAL=10  # 10 seconds
            ELAPSED_TIME=0
            
            while [ "$ELAPSED_TIME" -lt "$MAX_WAIT_TIME" ]; do
              RUNNING_INSTANCES=$(gcloud compute instances list \
                --filter="labels.env=${{ needs.resolve-env.outputs.env }} AND status=RUNNING" \
                --format="value(name)")
              
              ALL_INSTANCES=$(gcloud compute instances list \
                --filter="labels.env=${{ needs.resolve-env.outputs.env }}" \
                --format="value(name)")
              
              # Count total instances and running instances
              TOTAL_COUNT=$(echo "$ALL_INSTANCES" | wc -l)
              RUNNING_COUNT=$(echo "$RUNNING_INSTANCES" | wc -l)
              
              if [ "$TOTAL_COUNT" -eq "$RUNNING_COUNT" ]; then
                echo "All instances are now running."
                break
              else
                echo "Still waiting for instances to start. Running: $RUNNING_COUNT/$TOTAL_COUNT. Elapsed time: ${ELAPSED_TIME}s"
                sleep "$WAIT_INTERVAL"
                ELAPSED_TIME=$((ELAPSED_TIME + WAIT_INTERVAL))
              fi
            done
            
            if [ "$ELAPSED_TIME" -ge "$MAX_WAIT_TIME" ]; then
              echo "Warning: Some instances did not reach RUNNING state within the timeout."
            fi
          fi

      - name: Generate Ansible inventory (env=${{ needs.resolve-env.outputs.env }})
        env:
          GCP_PROJECT: ${{ vars.GCP_INFRA_PROJECT_ID }}
        run: |
          set -euo pipefail
          mkdir -p ansible
          
          ENV_VALUE="${{ needs.resolve-env.outputs.env }}"
          echo "Using env label value: '${ENV_VALUE}'"

          gcloud compute instances list \
            --project="${GCP_PROJECT}" \
            --filter="labels.env=${ENV_VALUE} AND status=RUNNING" \
            --format="value(name)" \
            > ansible/hosts.list

          echo "=== ansible/hosts.list ==="
          cat ansible/hosts.list || echo "NO INSTANCES FOUND"

          { echo "[gce]"; cat ansible/hosts.list; } > ansible/hosts.ini

          printf "%s\n" \
            "[defaults]" \
            "host_key_checking = False" \
            "[ssh_connection]" \
            "ssh_args = -o HostName=127.0.0.1 -o ProxyCommand=\"gcloud compute start-iap-tunnel %n 22 --project=${GCP_PROJECT} --zone=europe-west1-b --listen-on-stdin\" -o StrictHostKeyChecking=no" \
            > ansible/ansible.cfg

          if grep -Eq '([0-9]{1,3}\.){3}[0-9]{1,3}' ansible/hosts.ini; then
            echo "ERROR: hosts.ini contiene IPs. Usa FQDN GCE."
            cat ansible/hosts.ini
            exit 1
          fi
      - name: Debug inventory after generation
        run: |
          echo "=== ansible/hosts.list ==="
          cat ansible/hosts.list || echo "NO hosts in hosts.list"

          echo "=== ansible/hosts.ini ==="
          cat ansible/hosts.ini 

      - name: Upload inventory artifact
        uses: actions/upload-artifact@v4
        with:
          name: ansible-inventory-${{ needs.resolve-env.outputs.env }}
          path: |
            ansible/hosts.ini
            ansible/ansible.cfg
          retention-days: 14

  # ──────────────────────────────────────────────────────────────
  # 2) Ejecutar Ansible en el entorno detectado
  # ──────────────────────────────────────────────────────────────
  run_ansible:
    name: Run Ansible
    needs: [resolve-env, generate_inventory]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Auth GCP (OIDC)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ vars.GCP_SERVICE_ACCOUNT }}
          project_id: ${{ vars.GCP_INFRA_PROJECT_ID }}
          export_environment_variables: true

      - name: (DEBUG) List all instances in project
        run: |
          echo "Listing all instances in project ${{ vars.GCP_INFRA_PROJECT_ID }}..."
          gcloud compute instances list --project=${{ vars.GCP_INFRA_PROJECT_ID }}

      - name: Prepare gcloud SSH (IAP)
        id: prepare_ssh
        run: |
          set -e
          echo "Ensuring .ssh directory exists..."
          mkdir -p ~/.ssh
          echo "Setting gcloud project..."
          gcloud config set project ${{ vars.GCP_INFRA_PROJECT_ID }}
          echo "Running gcloud compute config-ssh..."
          gcloud compute config-ssh
        continue-on-error: true

      - name: Check generated SSH config
        # Solo ejecuta si el paso anterior fue 'success'
        if: ${{ steps.prepare_ssh.outcome == 'success' }}
        run: |
          echo "=== check generated SSH config ==="

          # 2) Si no hay fichero, se avisa pero NO es un error fatal
          if [ ! -f ~/.ssh/config ]; then
            echo ""WARNING: ~/.ssh/config file does not exist."
            echo ""Esto es normal si las VMs no tienen IP pública: 'gcloud compute config-ssh' sólo actualiza metadatos."
            exit 0
          fi
          
          # 3) Si existe, mostramos las lineas debug
          echo "SSH config file found. First lines:"
          head -n 40 ~/.ssh/config || true



      - name: Download inventory artifact to Ansible/
        uses: actions/download-artifact@v4
        with:
          name: ansible-inventory-${{ needs.resolve-env.outputs.env }}
          path: ansible

      - name: Install Ansible
        run: |
          sudo apt-get update -y
          sudo apt-get install -y ansible

      - name: Install Ansible Collections
        run: ansible-galaxy collection install -r ansible/requirements.yml

      - name: Run Ansible
        env:
          ANSIBLE_CONFIG: ansible/ansible.cfg
          ALERTMANAGER_SMTP_SMARTHOST: ${{ secrets.ALERT_SMTP_SMARTHOST }}
          ALERTMANAGER_SMTP_FROM:      ${{ secrets.ALERT_SMTP_FROM }}
          ALERTMANAGER_SMTP_USER:      ${{ secrets.ALERT_SMTP_USER }}
          ALERTMANAGER_SMTP_PASS:      ${{ secrets.ALERT_SMTP_PASS }}
          ALERTMANAGER_SMTP_TO:        ${{ secrets.ALERT_SMTP_TO }}
          GRAFANA_ADMIN_USER:         ${{ secrets.GRAFANA_ADMIN_USER }}
          GRAFANA_ADMIN_PASSWORD:     ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
        run: ansible-playbook -i ansible/hosts.ini ansible/site.yml
