name: Ansible-Inventory

on:
  workflow_dispatch:
    inputs:
      env:
        description: "Environment label (e.g. dev)"
        required: false
        default: "staging"
  workflow_run:
    workflows: ["terraform-apply"] # nombre exacto del workflow de apply
    branches: [staging]
    types: [completed]

permissions:
  contents: read
  id-token: write

concurrency:
  group: inv-ansible-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # ──────────────────────────────────────────────────────────────
  # 0) Resolver entorno a partir del workflow que nos ha llamado
  # ──────────────────────────────────────────────────────────────
  resolve-env:
    name: Resolve environment from trigger
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      env: ${{ steps.set-env.outputs.env }}
    permissions:
      actions: read # Requerido para descargar artefactos de otros workflows
    steps:
      - name: Download env artifact from triggering workflow
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        with:
          name: applied-env
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
      - name: Read env from file
        id: set-env
        run: |
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            echo "env=${{ inputs.env }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ ! -f env.txt ]; then
            echo "Missing env.txt from triggering workflow" >&2
            exit 1
          fi
          echo "env=$(cat env.txt)" >> $GITHUB_OUTPUT

  # ──────────────────────────────────────────────────────────────
  # 1) Generar inventario para el entorno detectado, y verificar si las instances están arrancadas.
  # ──────────────────────────────────────────────────────────────
  generate_inventory:
    name: Generate inventory
    needs: resolve-env
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    container:
      image: gcr.io/google.com/cloudsdktool/cloud-sdk@sha256:e5988181787670e47bab44136eefd93001baea254c49413b7ec03eae2e9470a5 # Digest del manifiesto de la versión 550.0.0
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Auth GCP (OIDC)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ vars.GCP_SERVICE_ACCOUNT }}
          project_id: ${{ vars.GCP_INFRA_PROJECT_ID }}
          export_environment_variables: true

      - name: Generate ephemeral SSH keypair
        run: |
          set -euo pipefail
          mkdir -p ansible
          SSH_KEY_PATH="ansible/gha_ansible"
          if [ -f "${SSH_KEY_PATH}" ]; then
            rm -f "${SSH_KEY_PATH}" "${SSH_KEY_PATH}.pub"
          fi
          ssh-keygen -t ed25519 -f "${SSH_KEY_PATH}" -N "" -C "gha-ansible@gha"
          chmod 600 "${SSH_KEY_PATH}"
          echo "ANSIBLE_SSH_KEY_PATH=${SSH_KEY_PATH}" >> "$GITHUB_ENV"

      - name: Register SSH key with OS Login
        run: |
          set -euo pipefail
          : "${ANSIBLE_SSH_KEY_PATH:?ANSIBLE_SSH_KEY_PATH is required}"

          
          gcloud compute os-login ssh-keys add \
            --key-file="${ANSIBLE_SSH_KEY_PATH}.pub" \
            --ttl=1h \
            --impersonate-service-account=${{ vars.GCP_SERVICE_ACCOUNT }}

          SSH_USER=$(gcloud compute os-login describe-profile \
            --impersonate-service-account=${{ vars.GCP_SERVICE_ACCOUNT }} \
            --format='value(posixAccounts[0].username)')
          if [ -z "$SSH_USER" ]; then
            echo "OS Login user not found in profile" >&2
            exit 1
          fi
          echo "${SSH_USER}" > ansible/ssh_user.txt
          echo "ANSIBLE_SSH_USER=${SSH_USER}" >> "$GITHUB_ENV"


      - name: Ensure GCP VMs are running
        run: |
          set -euo pipefail
          echo "Checking for stopped GCP instances in environment: ${{ needs.resolve-env.outputs.env }}"
          
          # List all instances for the environment, filter for TERMINATED ones
          STOPPED_INSTANCES=$(gcloud compute instances list \
            --filter="labels.env=${{ needs.resolve-env.outputs.env }} AND (status=TERMINATED OR status=STOPPED OR status=SUSPENDED)" \
            --format="value(name,zone.basename())")

          if [ -z "$STOPPED_INSTANCES" ]; then
            echo "No stopped instances found for environment: ${{ needs.resolve-env.outputs.env }}"
          else
            echo "Found stopped instances. Attempting to start them:"
            echo "$STOPPED_INSTANCES" | while IFS=$'\t' read -r INSTANCE_NAME INSTANCE_ZONE; do
              INSTANCE_NAME=${INSTANCE_NAME%$'\r'}
              INSTANCE_ZONE=${INSTANCE_ZONE%$'\r'}
              echo "Starting instance: $INSTANCE_NAME in zone: $INSTANCE_ZONE"
              gcloud compute instances start "$INSTANCE_NAME" --zone="$INSTANCE_ZONE" --quiet
            done
            echo "All identified stopped instances have been commanded to start."
            
            # Optional: Add a wait loop to ensure instances are running before proceeding
            echo "Waiting for instances to reach RUNNING state..."
            MAX_WAIT_TIME=300 # 5 minutes
            WAIT_INTERVAL=10  # 10 seconds
            ELAPSED_TIME=0
            
            while [ "$ELAPSED_TIME" -lt "$MAX_WAIT_TIME" ]; do
              RUNNING_INSTANCES=$(gcloud compute instances list \
                --filter="labels.env=${{ needs.resolve-env.outputs.env }} AND status=RUNNING" \
                --format="value(name)")
              
              ALL_INSTANCES=$(gcloud compute instances list \
                --filter="labels.env=${{ needs.resolve-env.outputs.env }}" \
                --format="value(name)")
              
              # Count total instances and running instances (solo líneas no vacías)
              TOTAL_COUNT=$(echo "$ALL_INSTANCES" | grep -c . || true)
              RUNNING_COUNT=$(echo "$RUNNING_INSTANCES" | grep -c . || true)
              
              if [ "$TOTAL_COUNT" -eq "$RUNNING_COUNT" ] && [ "$TOTAL_COUNT" -gt 0 ]; then
                echo "All instances are now running."
                break
              else
                echo "Still waiting for instances to start. Running: $RUNNING_COUNT/$TOTAL_COUNT. Elapsed time: ${ELAPSED_TIME}s"
                sleep "$WAIT_INTERVAL"
                ELAPSED_TIME=$((ELAPSED_TIME + WAIT_INTERVAL))
              fi
            done
            
            if [ "$ELAPSED_TIME" -ge "$MAX_WAIT_TIME" ]; then
              echo "Warning: Some instances did not reach RUNNING state within the timeout."
            fi
          fi

      - name: Discover running instances (env=${{ needs.resolve-env.outputs.env }})
        env:
          GCP_PROJECT: ${{ vars.GCP_INFRA_PROJECT_ID }}
        run: |
          set -euo pipefail
          mkdir -p ansible
          
          ENV_VALUE="${{ needs.resolve-env.outputs.env }}"
          echo "Using env label value: '${ENV_VALUE}'"

          gcloud compute instances list \
            --project="${GCP_PROJECT}" \
            --filter="labels.env=${ENV_VALUE} AND status=RUNNING" \
            --format="value(name,zone.basename())" \
            > ansible/hosts_with_zones.list

          cut -f1 ansible/hosts_with_zones.list > ansible/hosts.list || true

          echo "=== ansible/hosts.list ==="
          cat ansible/hosts.list || echo "NO INSTANCES FOUND"
          echo "=== ansible/hosts_with_zones.list ==="
          cat ansible/hosts_with_zones.list || echo "NO INSTANCES WITH ZONE"

      - name: Warm up SSH access via IAP
        env:
          GCP_PROJECT: ${{ vars.GCP_INFRA_PROJECT_ID }}
        run: |
          set -euo pipefail
          : "${ANSIBLE_SSH_KEY_PATH:?ANSIBLE_SSH_KEY_PATH is required}"
          : "${ANSIBLE_SSH_USER:?ANSIBLE_SSH_USER is required}"

          if [ ! -s ansible/hosts_with_zones.list ]; then
            echo "No hosts to warm up."
            exit 0
          fi

          while IFS=$'\t' read -r INSTANCE_NAME INSTANCE_ZONE; do
            if [ -z "$INSTANCE_NAME" ]; then
              continue
            fi
            INSTANCE_NAME=${INSTANCE_NAME%$'\r'}
            INSTANCE_ZONE=${INSTANCE_ZONE%$'\r'}
            if [ -z "$INSTANCE_NAME" ] || [ -z "$INSTANCE_ZONE" ]; then
              echo "Skipping entry with empty name or zone: '${INSTANCE_NAME}' '${INSTANCE_ZONE}'"
              continue
            fi

            ZONE_ARG=$(echo "${INSTANCE_ZONE}" | awk -F/ '{print $NF}')
            echo "Warming up SSH access for ${INSTANCE_NAME} (${ZONE_ARG})"
            for attempt in $(seq 1 5); do
              if ssh \
                -i "${ANSIBLE_SSH_KEY_PATH}" \
                -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=/dev/null \
                -o ProxyCommand="gcloud compute start-iap-tunnel ${INSTANCE_NAME} 22 --project=${GCP_PROJECT} --zone=${ZONE_ARG} --listen-on-stdin --quiet" \
                "${ANSIBLE_SSH_USER}@127.0.0.1" \
                "true"; then
                echo "SSH warm-up succeeded for ${INSTANCE_NAME}"
                break
              fi

              if [ "$attempt" -eq 5 ]; then
                echo "ERROR: SSH warm-up failed for ${INSTANCE_NAME} after 5 attempts"
                exit 1
              fi

              echo "Retrying SSH warm-up for ${INSTANCE_NAME} (attempt $((attempt + 1)))"
              sleep 5
            done
          done < ansible/hosts_with_zones.list

      - name: Generate Ansible inventory (env=${{ needs.resolve-env.outputs.env }})
        env:
          GCP_PROJECT: ${{ vars.GCP_INFRA_PROJECT_ID }}
        run: |
          set -euo pipefail
          : "${ANSIBLE_SSH_KEY_PATH:?ANSIBLE_SSH_KEY_PATH is required}"
          : "${ANSIBLE_SSH_USER:?ANSIBLE_SSH_USER is required}"

          if [ ! -s ansible/hosts_with_zones.list ]; then
            echo "ERROR: hosts_with_zones.list is empty."
            exit 1
          fi

          echo "Rendering inventory with SSH user ${ANSIBLE_SSH_USER}"
          {
            echo "[gce]"
          while IFS=$'\t' read -r INSTANCE_NAME INSTANCE_ZONE; do
            if [ -z "$INSTANCE_NAME" ]; then
              continue
            fi
              INSTANCE_NAME=${INSTANCE_NAME%$'\r'}
              INSTANCE_ZONE=${INSTANCE_ZONE%$'\r'}
              if [ -z "$INSTANCE_NAME" ] || [ -z "$INSTANCE_ZONE" ]; then
                echo "Skipping entry with empty name or zone: '${INSTANCE_NAME}' '${INSTANCE_ZONE}'"
                continue
              fi

              SSH_ARGS="-i ${ANSIBLE_SSH_KEY_PATH} -o ProxyCommand=\"gcloud compute start-iap-tunnel ${INSTANCE_NAME} 22 --project=${GCP_PROJECT} --zone=${INSTANCE_ZONE} --listen-on-stdin --quiet\" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o CheckHostIP=no"
              printf "%s ansible_user=%s ansible_host=127.0.0.1 ansible_ssh_private_key_file=%s ansible_ssh_common_args='%s'\n" \
                "$INSTANCE_NAME" \
                "$ANSIBLE_SSH_USER" \
                "${ANSIBLE_SSH_KEY_PATH}" \
                "$SSH_ARGS"
            done < ansible/hosts_with_zones.list
          } > ansible/hosts.ini

          printf "%s\n" \
            "[defaults]" \
            "host_key_checking = False" \
            > ansible/ansible.cfg

          if ! grep -q 'ansible_host=' ansible/hosts.ini; then
            echo "ERROR: No hosts rendered into hosts.ini"
            cat ansible/hosts.ini || true
            exit 1
          fi
      - name: Debug inventory after generation
        run: |
          echo "=== ansible/hosts.list ==="
          cat ansible/hosts.list || echo "NO hosts in hosts.list"

          echo "=== ansible/hosts.ini ==="
          cat ansible/hosts.ini 

      - name: Upload inventory artifact
        uses: actions/upload-artifact@v4
        with:
          name: ansible-inventory-${{ needs.resolve-env.outputs.env }}
          path: |
            ansible/hosts.ini
            ansible/ansible.cfg
            ansible/gha_ansible
            ansible/gha_ansible.pub
            ansible/ssh_user.txt
            ansible/hosts_with_zones.list
          retention-days: 10

  # ──────────────────────────────────────────────────────────────
  # 2) Ejecutar Ansible en el entorno detectado
  # ──────────────────────────────────────────────────────────────
  run_ansible:
    name: Run Ansible
    needs: [resolve-env, generate_inventory]
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    container:
      image: gcr.io/google.com/cloudsdktool/cloud-sdk@sha256:e5988181787670e47bab44136eefd93001baea254c49413b7ec03eae2e9470a5 # Manifiesto digest de la versión 550.0.0
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Auth GCP (OIDC)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ vars.GCP_SERVICE_ACCOUNT }}
          project_id: ${{ vars.GCP_INFRA_PROJECT_ID }}
          export_environment_variables: true

      - name: (DEBUG) List all instances in project
        run: |
          echo "Listing all instances in project ${{ vars.GCP_INFRA_PROJECT_ID }}..."
          gcloud compute instances list --project=${{ vars.GCP_INFRA_PROJECT_ID }}

      - name: Prepare gcloud SSH (IAP)
        id: prepare_ssh
        run: |
          set -e
          echo "Ensuring .ssh directory exists..."
          mkdir -p ~/.ssh
          echo "Setting gcloud project..."
          gcloud config set project ${{ vars.GCP_INFRA_PROJECT_ID }}
          echo "Running gcloud compute config-ssh..."
          gcloud compute config-ssh
        continue-on-error: true

      - name: Check generated SSH config
        # Solo ejecuta si el paso anterior fue 'success'
        if: ${{ steps.prepare_ssh.outcome == 'success' }}
        run: |
          echo "=== check generated SSH config ==="

          # 2) Si no hay fichero, se avisa pero NO es un error fatal
          if [ ! -f ~/.ssh/config ]; then
            echo "WARNING: ~/.ssh/config file does not exist."
            echo "Esto es normal si las VMs no tienen IP pública: 'gcloud compute config-ssh' sólo actualiza metadatos."
            exit 0
          fi
          
          # 3) Si existe, mostramos las lineas debug
          echo "SSH config file found. First lines:"
          head -n 40 ~/.ssh/config || true



      - name: Download inventory artifact to Ansible/
        uses: actions/download-artifact@v4
        with:
          name: ansible-inventory-${{ needs.resolve-env.outputs.env }}
          path: ansible

      - name: Prepare downloaded SSH key
        run: |
          set -euo pipefail
          if [ ! -f ansible/gha_ansible ]; then
            echo "Missing SSH private key in artifact"
            exit 1
          fi
          chmod 600 ansible/gha_ansible
          if [ -f ansible/ssh_user.txt ]; then
            SSH_USER=$(cat ansible/ssh_user.txt)
            echo "ANSIBLE_SSH_USER=${SSH_USER}" >> "$GITHUB_ENV"
          fi

      - name: Install Ansible
        run: |
          apt-get update -y
          apt-get install -y python3-venv
          python3 -m venv /opt/ansible-venv
          /opt/ansible-venv/bin/python -m pip install --no-cache-dir "ansible-core==2.17.*"
          echo "/opt/ansible-venv/bin" >> "$GITHUB_PATH"

      - name: Cache Ansible collections and pip
        uses: actions/cache@v4
        with:
          path: |
            ~/.ansible/collections
            ~/.cache/pip
          key: ansible-cache-${{ runner.os }}-${{ hashFiles('ansible/requirements.yml') }}
          restore-keys: |
            ansible-cache-${{ runner.os }}-

      - name: Install Ansible Collections
        run: ansible-galaxy collection install -r ansible/requirements.yml

      - name: Run Ansible
        env:
          ANSIBLE_CONFIG: ansible/ansible.cfg
          ALERTMANAGER_SMTP_SMARTHOST: ${{ secrets.ALERT_SMTP_SMARTHOST }}
          ALERTMANAGER_SMTP_FROM:      ${{ secrets.ALERT_SMTP_FROM }}
          ALERTMANAGER_SMTP_USER:      ${{ secrets.ALERT_SMTP_USER }}
          ALERTMANAGER_SMTP_PASS:      ${{ secrets.ALERT_SMTP_PASS }}
          ALERTMANAGER_SMTP_TO:        ${{ secrets.ALERT_SMTP_TO }}
          GRAFANA_ADMIN_USER:         ${{ secrets.GRAFANA_ADMIN_USER }}
          GRAFANA_ADMIN_PASSWORD:     ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
        run: ansible-playbook -i ansible/hosts.ini ansible/site.yml

      - name: Cleanup ephemeral SSH key from instances
        if: always()
        run: |
          echo "OS Login key uses TTL; no instance metadata cleanup needed."

  # ──────────────────────────────────────────────────────────────
  # 4) Construir instrucciones de túnel IAP a servicios (Prometheus, Grafana, Nginx)
  # ──────────────────────────────────────────────────────────────
  publish_tunnel_instructions:
    name: Publish tunnel commands
    needs: [resolve-env, generate_inventory, run_ansible]
    runs-on: ubuntu-latest
    steps:
      - name: Download inventory artifact
        uses: actions/download-artifact@v4
        with:
          name: ansible-inventory-${{ needs.resolve-env.outputs.env }}
          path: ansible

      - name: Build tunnel instructions
        run: |
          set -euo pipefail
          HOST_LINE=$(head -n1 ansible/hosts_with_zones.list || true)
          HOST=$(echo "$HOST_LINE" | awk '{print $1}')
          ZONE=$(echo "$HOST_LINE" | awk '{print $2}')

          if [ -z "$HOST" ] || [ -z "$ZONE" ]; then
            HOST="<vm-name>"
            ZONE="<zone>"
          fi

          cat > tunnel.txt <<EOF
          # Open Prometheus tunnel (9090) via SSH (IAP)
          gcloud compute ssh ${HOST} \\
            --project=${{ vars.GCP_INFRA_PROJECT_ID }} \\
            --zone=${ZONE} \\
            -- -L9090:localhost:9090
          
          # Open Grafana tunnel (3000)
          gcloud compute ssh ${HOST} \\
            --project=${{ vars.GCP_INFRA_PROJECT_ID }} \\
            --zone=${ZONE} \\
            -- -L3000:localhost:3000
          
          # Open Nginx landing page (80)
          gcloud compute ssh ${HOST} \\
            --project=${{ vars.GCP_INFRA_PROJECT_ID }} \\
            --zone=${ZONE} \\
            -- -L8080:localhost:80
          
          # SSH a la VM (shell) via IAP
          gcloud compute ssh ${HOST} \\
            --project=${{ vars.GCP_INFRA_PROJECT_ID }} \\
            --zone=${ZONE} \\
            --tunnel-through-iap
          
          # Luego navega a:
          #   Prometheus -> http://localhost:9090
          #   Grafana    -> http://localhost:3000
          #   Nginx      -> http://localhost:8080
          EOF

          cat tunnel.txt

      - name: Upload tunnel commands
        uses: actions/upload-artifact@v4
        with:
          name: iap-tunnel-${{ needs.resolve-env.outputs.env }}
          path: tunnel.txt
          retention-days: 14
